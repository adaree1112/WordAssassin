<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Word Assassin Generator</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  textarea { width: 100%; height: 120px; }
  table { border-collapse: collapse; width: 100%; margin-top: 15px; }
  th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
  th { background: #4CAF50; color: white; }
  td[contenteditable="true"] { background: #f9f9f9; }
  button { margin: 5px; padding: 8px 12px; cursor: pointer; }
  .controls { margin: 10px 0; }
</style>
</head>
<body>

<h2>Word Assassin Generator</h2>

<label>Enter names (one per line):</label><br>
<textarea id="names"></textarea><br><br>

<label>Select difficulty: </label>
<select id="difficulty"></select>

<div class="controls">
  <button onclick="generatePreview()">Generate Preview</button>
  <button onclick="downloadCSV()">Download CSV</button>
  <button onclick="downloadPDF()">Download PDF</button>
  <button onclick="printPDF()">Print</button>
</div>

<h3>Preview (double-click Random Word to edit):</h3>
<table id="previewTable">
  <thead>
    <tr>
      <th>Previous Name</th>
      <th>Name</th>
      <th>Random Word</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script>
let words = {};
let previewData = [];

// Load words.json
fetch("words.json")
  .then(res => res.json())
  .then(data => {
    words = data;
    let diffSelect = document.getElementById("difficulty");
    Object.keys(words).forEach(level => {
      let opt = document.createElement("option");
      opt.value = level;
      opt.textContent = level;
      diffSelect.appendChild(opt);
    });
  });

function getRandomWords(count, difficulty) {
  let pool = [...words[difficulty]];
  if (count > pool.length) {
    alert("Not enough words in " + difficulty + " list.");
    return [];
  }
  let selected = [];
  while (selected.length < count) {
    let idx = Math.floor(Math.random() * pool.length);
    selected.push(pool.splice(idx, 1)[0]);
  }
  return selected;
}

function buildData() {
  let names = document.getElementById("names").value
    .split("\n")
    .map(n => n.trim())
    .filter(n => n);
  
  if (names.length < 3) {
    alert("Please enter at least 3 names.");
    return [];
  }

  let difficulty = document.getElementById("difficulty").value;
  let randomWords = getRandomWords(names.length, difficulty);

  // Shuffle names ensuring no adjacent repeats
  let shuffled = [];
  let tries = 0;
  const maxTries = 1000; // prevent infinite loop
  do {
    shuffled = [...names].sort(() => Math.random() - 0.5);
    tries++;
    if (tries > maxTries) break;
  } while (shuffled.some((name, i) => name === (i === 0 ? shuffled[shuffled.length - 1] : shuffled[i - 1])));

  let data = [];
  for (let i = 0; i < shuffled.length; i++) {
    let prev = i === 0 ? shuffled[shuffled.length - 1] : shuffled[i - 1];
    data.push([prev, shuffled[i], randomWords[i]]);
  }

  return data;
}



  names.sort(() => Math.random() - 0.5); // shuffle

  let difficulty = document.getElementById("difficulty").value;
  let randomWords = getRandomWords(names.length, difficulty);

  let data = [];
  for (let i = 0; i < names.length; i++) {
    let prev = i === 0 ? names[names.length - 1] : names[i - 1];
    data.push([prev, names[i], randomWords[i]]);
  }
  return data;
}

function generatePreview() {
  previewData = buildData();
  renderTable();
}

function renderTable() {
  let tbody = document.querySelector("#previewTable tbody");
  tbody.innerHTML = "";
  previewData.forEach((row, i) => {
    let tr = document.createElement("tr");
    row.forEach((cell, j) => {
      let td = document.createElement("td");
      td.textContent = cell;
      if (j === 2) {
        td.contentEditable = "true";
        td.addEventListener("input", () => {
          previewData[i][2] = td.textContent;
        });
      }
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

function downloadCSV() {
  let data = previewData.length ? previewData : buildData();
  if (!data.length) return;

  let csv = "Previous Name,Name,Random Word\n" +
    data.map(r => r.join(",")).join("\n");
  let blob = new Blob([csv], { type: "text/csv" });
  let a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "output.csv";
  a.click();
}

function downloadPDF() {
  generatePDF().save("output.pdf");
}

function printPDF() {
  const doc = generatePDF();
  doc.autoPrint(); // instruct PDF to open in print mode
  const blobURL = doc.output('bloburl'); // create a URL for PDF in memory
  const printWindow = window.open(blobURL); // open PDF in new window
  printWindow.focus(); // focus the window
  // The PDF itself triggers the print dialog via autoPrint
}

function generatePDF() {
  let data = previewData.length ? previewData : buildData();
  if (!data.length) return;

  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ unit: "pt", format: "a4" });

  const margin = 40; // equal page margins
  const pageWidth = doc.internal.pageSize.getWidth();
  const usableWidth = pageWidth - margin * 2;
  const colWidth = usableWidth / 3;

  doc.autoTable({
    head: [["Previous Name", "Name", "Random Word"]],
    body: data,
    startY: margin,
    theme: "grid",
    tableWidth: usableWidth,
    styles: {
      halign: "center",
      valign: "middle",
      fontSize: 10,
      cellPadding: 4,
      overflow: 'linebreak',
      minCellHeight: 0
    },
    columnStyles: {
      0: { cellWidth: colWidth },
      1: { cellWidth: colWidth },
      2: { cellWidth: colWidth }
    },
    headStyles: { fillColor: [128,128,128], textColor: 255, fontStyle: "bold" },
    tableLineWidth: 0.5,
    tableLineColor: [0,0,0],
    didDrawCell: (dataCell) => {
      dataCell.cell.styles.lineWidth = { top: 0.5, bottom: 0.5, left: 0, right: 0 };
    },
    margin: { left: margin, right: margin }
  });

  return doc;
}
</script>
</body>
</html>
